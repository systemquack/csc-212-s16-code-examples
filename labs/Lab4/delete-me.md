In this project you will implement a class for a **Union-Find** data structure.  Your class should implement at least the three basic methods in union-find data structures, `find`, `connect`, and `connected`.  Your implementation will be part of a program that can create a **Maze**, i.e. a two-dimensional visual puzzle which can be traversed, defined by walls and cells.  The goal in a maze is to find a path connecting the cell at the start location (top-left) with the cell at the finish location (bottom-right).  In this project, we are interested in an automatic way for constructing mazes that have exactly one solution.  We are providing starter code for constructing a Maze, based on *Algorithm 7.4* from the textbook, and also, a Python script for visualizing the Maze.

## Starter files
You will find the starter files in the Github repository (URL posted on Piazza), under the folder `pa-1/`.

| `uf.h` | This header file defines the class <samp>UF</samp> which implements the Union-Find data structure.  You can modify this file and add more data members or methods to the class.  You are required to submit this file. |
| `uf.cpp` | This source file implements the methods defined in class <samp>UF</samp>.  You are provided with a full implementation of quick-find.  Your goal is to change the implementation of this class to a more efficient implementation (for example: quick-union, or weighted quick-union, or weighted quick-union with path compression).  You are required to modify and submit this file. |
| `main.cpp` | This source file generates the maze.  It takes the value of *N* as a command line parameter, and after generating an *NxN* maze, prints the maze encoded as a matrix of numbers to `stdout` (standard output).  We will be timing this program for ranking all solutions (bonus points).  You are encouraged to understand this file, but you do not need to modify it. |
| `draw-maze.py` | This Python 2.7 script will implement the visualization of the maze.  Once you have the output generated by `main`, it can be visualized using this script.  The script requires you to specify the encoded maze as standard input.  You are not required to modify this file.  Python usually comes pre-installed with OS X distributions.  If you are using Windows this [link](http://introcs.cs.princeton.edu/python/windows/) may help. |
{: .table .table-bordered .table-hover}

If you want to compile this program in a bash shell, you only need to type:
{% highlight bash %}
$ g++ main.cpp uf.cpp -o main
{% endhighlight %}

The program will print the maze, as a matrix of numbers, to the standard output (`stdout`), and the total running time used for creating the maze to the standard error output (`stderr`). After your binary file has been generated.  You can use the program to generate and visualize the maze as follows.
{% highlight bash %}
# generates an 32x32 maze
$ ./main 32
# to save this maze into a file, you can redirect stdout to a file and stderr to an error file
$ ./main 32 > maze-32.txt 2> maze-32-time.txt
# to visualize the file generated by 'main' you need to provide the file as standard input
$ python draw-maze.py < maze-32.txt
{% endhighlight %}

You can also do the same without saving any extra file, using pipes.
{% highlight bash %}
# generates and visualizes an 32x32 maze
$ ./main 32 | python draw-maze.py
{% endhighlight %}

![](./files/maze-32.png){: height="500px" .center-block}

## Grading
There are 100 possible points on the assignment.  If your solution files do not compile or link error-free, you will receive **zero** points.  We will compile and run your solutions on a linux bash shell (if you are using Mac OS X, a shell is available by running the `Terminal` app).  The point distribution is as follows:

* 15 points for good coding style and informative comments
* 60 points for a correct implementation of Quick Union (as shown in lectures)
* 10 additional points for implementing Weighted Quick Union
* 15 additional points for implementing Path Compression

In order to get full points your program should be able to correctly generate, **without crashing**, mazes of at least size *500x500*.

<div class="panel panel-danger">
    <div class="panel-heading"><h3 class="panel-title">Important</h3></div>
    <div class="panel-body">
    You are only required to submit <code>uf.h</code> and <code>uf.cpp</code>.  Feel free to add any private methods to the class <samp>UF</samp>, in order to accomplish your goals of developing a more efficient implementation.  However, do not remove <code>find</code>, <code>connect</code>, nor <code>connected</code>, as they are your interface to the world.
    </div>
</div>

## Due Date and Submission
You will **only** submit files `uf.cpp` and `uf.h`, which contain your Union-Find class implementation and specification respectively.  You will receive a message in your e-mail with sign-up information for <kbd>Autolab</kbd> (the tool we use for collecting and grading programming assignments) and detailed information on how to make a submission.  This assignment is due on **Tuesday Feb 23rd**.

- This assignment can be done in teams of either 1 or 2 students.
- We will be running checks for plagiarism.  If your code is caught, you will be called for an interview before determining your grade.  As we want to minimize the number of false negatives, we will eventually call a few false positives for an interview ('positive' being an actual cheater).

<div class="panel panel-success">
    <div class="panel-heading"><h3 class="panel-title">Bonus Points</h3></div>
    <div class="panel-body">
    We will rank all submissions by running time.  We will award +15 extra points to the 3rd, 4th, and 5th places; +25 extra points to the 2nd place; and +30 extra points to the 1st place.
    </div>
</div>

